USE yazicia;

-- DROP EXISTING TRIGGERS (if exist)
DROP TRIGGER IF EXISTS trg_custorder_status_change;
DROP TRIGGER IF EXISTS trg_sellerorder_status_change;
DROP TRIGGER IF EXISTS trg_shipment_status_change;
DROP TRIGGER IF EXISTS trg_shipment_confirm_stock;
DROP TRIGGER IF EXISTS trg_returnitem_increase_rebound;
DROP TRIGGER IF EXISTS trg_returnitem_stock_movement;
DROP TRIGGER IF EXISTS trg_shipmentitem_stock_movement;
DROP TRIGGER IF EXISTS trg_orderitem_seller_consistency;
DROP TRIGGER IF EXISTS trg_statushistory_xor_insert;
DROP TRIGGER IF EXISTS trg_shipment_payment_check;
DROP TRIGGER IF EXISTS trg_review_delivery_check;
DROP TRIGGER IF EXISTS trg_sellerorder_completion_check;
DROP TRIGGER IF EXISTS trg_sellerorder_rollup_status;
DROP TRIGGER IF EXISTS trg_reservation_stock_movement;
DROP TRIGGER IF EXISTS trg_shipment_allocation_check;
DROP TRIGGER IF EXISTS trg_return_lifecycle;
DROP TRIGGER IF EXISTS trg_basket_one_active;
DROP TRIGGER IF EXISTS trg_orderitem_active_listing;

-- DROP EXISTING PROCEDURES (if exist)
DROP PROCEDURE IF EXISTS sp_convert_basket_to_order;
DROP PROCEDURE IF EXISTS sp_cancel_seller_order;
DROP PROCEDURE IF EXISTS sp_cancel_customer_order;
DROP PROCEDURE IF EXISTS sp_seller_restock;

-- DROP EXISTING FUNCTIONS (if exist)
DROP FUNCTION IF EXISTS fn_calculate_order_total;
DROP FUNCTION IF EXISTS fn_get_available_stock;
DROP FUNCTION IF EXISTS fn_calculate_seller_earnings;

DELIMITER $$
-- TRIGGER: Auto-insert into Order_Status_History on Customer_Order status change
CREATE TRIGGER trg_custorder_status_change
AFTER UPDATE ON Customer_Order
FOR EACH ROW
BEGIN
    IF OLD.status <> NEW.status THEN
        INSERT INTO Order_Status_History (
            cust_order_id, 
            seller_order_id, 
            shipment_id, 
            old_status, 
            new_status, 
            changed_at, 
            changed_by
        ) VALUES (
            NEW.cust_order_id, 
            NULL, 
            NULL, 
            OLD.status, 
            NEW.status, 
            NOW(), 
            NULL
        );
    END IF;
END$$

-- TRIGGER: Auto-insert into Order_Status_History on Seller_Order status change
CREATE TRIGGER trg_sellerorder_status_change
AFTER UPDATE ON Seller_Order
FOR EACH ROW
BEGIN
    IF OLD.status <> NEW.status THEN
        INSERT INTO Order_Status_History (
            cust_order_id, 
            seller_order_id, 
            shipment_id, 
            old_status, 
            new_status, 
            changed_at, 
            changed_by
        ) VALUES (
            NULL, 
            NEW.seller_order_id, 
            NULL, 
            OLD.status, 
            NEW.status, 
            NOW(), 
            NULL
        );
    END IF;
END$$


-- TRIGGER: Auto-insert into Order_Status_History on Shipment status change
CREATE TRIGGER trg_shipment_status_change
AFTER UPDATE ON Shipment
FOR EACH ROW
BEGIN
    IF OLD.status <> NEW.status THEN
        INSERT INTO Order_Status_History (
            cust_order_id, 
            seller_order_id, 
            shipment_id, 
            old_status, 
            new_status, 
            changed_at, 
            changed_by
        ) VALUES (
            NULL, 
            NULL, 
            NEW.shipment_id, 
            OLD.status, 
            NEW.status, 
            NOW(), 
            NULL
        );
    END IF; 
END$$


-- TRIGGER: Update Listing stock on Shipment status = 'Shipped'
CREATE TRIGGER trg_shipment_confirm_stock
AFTER UPDATE ON Shipment
FOR EACH ROW
BEGIN
    IF NEW.status = 'Shipped' AND OLD.status <> 'Shipped' THEN
        -- For each shipment item, reduce reserved and stock_on_hand
        UPDATE Listing l
        INNER JOIN Order_Item oi ON oi.listing_id = l.listing_id
        INNER JOIN Shipment_Item si ON si.order_item_id = oi.order_item_id
        SET 
            l.reserved = GREATEST(l.reserved - si.shipped_quantity, 0),
            l.stock_on_hand = GREATEST(l.stock_on_hand - si.shipped_quantity, 0)
        WHERE si.shipment_id = NEW.shipment_id;
    END IF;
END$$


-- TRIGGER: Update Listing stock on Return_Item INSERT
CREATE TRIGGER trg_returnitem_increase_rebound
AFTER INSERT ON Return_Item
FOR EACH ROW
BEGIN
    DECLARE v_listing_id INT;
    
    SELECT listing_id INTO v_listing_id
    FROM Order_Item
    WHERE order_item_id = NEW.order_item_id;
    
    -- Increase both rebound (tracking) and stock_on_hand (sellable inventory)
    UPDATE Listing
    SET rebound = rebound + NEW.quantity,
        stock_on_hand = stock_on_hand + NEW.quantity
    WHERE listing_id = v_listing_id;
END$$


-- TRIGGER: Create Stock_Movement record on Return_Item INSERT (inbound)
CREATE TRIGGER trg_returnitem_stock_movement
AFTER INSERT ON Return_Item
FOR EACH ROW
BEGIN
    DECLARE v_listing_id INT;

    SELECT listing_id INTO v_listing_id
    FROM Order_Item
    WHERE order_item_id = NEW.order_item_id;

    INSERT INTO Stock_Movement (
        listing_id,
        order_item_id,
        return_item_id,
        movement_type,
        quantity,
        created_at
    ) VALUES (
        v_listing_id,
        NEW.order_item_id,
        NEW.return_item_id,
        'RETURN_INBOUND',
        NEW.quantity,
        NOW()
    );
END$$

-- TRIGGER: Create Stock_Movement record on Shipment_Item INSERT (outbound)
CREATE TRIGGER trg_shipmentitem_stock_movement
AFTER INSERT ON Shipment_Item
FOR EACH ROW
BEGIN
    DECLARE v_listing_id INT;

    SELECT listing_id INTO v_listing_id
    FROM Order_Item
    WHERE order_item_id = NEW.order_item_id;

    INSERT INTO Stock_Movement (
        listing_id,
        order_item_id,
        return_item_id,
        movement_type,
        quantity,
        created_at
    ) VALUES (
        v_listing_id,
        NEW.order_item_id,
        NULL,
        'SHIPMENT_OUTBOUND',
        NEW.shipped_quantity,
        NOW()
    );
END$$


-- TRIGGER: Enforce seller consistency between Order_Item and Seller_Order
CREATE TRIGGER trg_orderitem_seller_consistency
BEFORE INSERT ON Order_Item
FOR EACH ROW
BEGIN
    DECLARE v_listing_seller INT;
    DECLARE v_order_seller INT;

    SELECT seller_id INTO v_listing_seller
    FROM Listing WHERE listing_id = NEW.listing_id;

    SELECT seller_id INTO v_order_seller
    FROM Seller_Order WHERE seller_order_id = NEW.seller_order_id;

    IF v_listing_seller IS NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Listing not found';
    ELSEIF v_order_seller IS NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Seller order not found';
    ELSEIF v_listing_seller <> v_order_seller THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Seller mismatch: listing seller does not match seller order';
    END IF;
END$$




-- Order_Status_History: exactly one of cust_order_id, seller_order_id, or shipment_id must be non-null
CREATE TRIGGER trg_statushistory_xor_insert
BEFORE INSERT ON Order_Status_History
FOR EACH ROW
BEGIN
    DECLARE v_count INT;
    SET v_count = (NEW.cust_order_id IS NOT NULL) + 
                  (NEW.seller_order_id IS NOT NULL) + 
                  (NEW.shipment_id IS NOT NULL);
    
    IF v_count <> 1 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Order_Status_History: Exactly one of cust_order_id, seller_order_id, or shipment_id must be set';
    END IF;
END$$





-- PROCEDURE: Convert Basket to Order (with FOR UPDATE locking)
CREATE PROCEDURE sp_convert_basket_to_order(
    IN p_basket_id INT,
    IN p_order_number VARCHAR(50),
    OUT p_cust_order_id INT
)
BEGIN
    DECLARE v_customer_id INT;
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_listing_id INT;
    DECLARE v_seller_id INT;
    DECLARE v_quantity INT;
    DECLARE v_unit_price DECIMAL(19,4);
    DECLARE v_vat_rate DECIMAL(5,2);
    DECLARE v_basket_item_id INT;
    DECLARE v_seller_order_id INT;
    DECLARE v_new_order_item_id INT;
    DECLARE v_reserved_qty INT;
    
    -- Cursor for basket items
    DECLARE basket_cursor CURSOR FOR
        SELECT bi.basket_item_id, bi.listing_id, l.seller_id, bi.quantity, bi.unit_price_at_sale, bi.vat_rate_at_sale
        FROM Basket_Item bi
        JOIN Listing l ON bi.listing_id = l.listing_id
        WHERE bi.basket_id = p_basket_id;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- Error handler: rollback on any error
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- Get customer from basket
    SELECT customer_id INTO v_customer_id
    FROM Basket
    WHERE basket_id = p_basket_id;
    
    -- Explicit check for basket not found
    IF v_customer_id IS NULL THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Basket not found or has no customer';
    END IF;
    
    -- Create Customer_Order
    INSERT INTO Customer_Order (
        customer_id, 
        ord_number, 
        ord_date, 
        status
    ) VALUES (
        v_customer_id, 
        p_order_number, 
        NOW(), 
        'Created'
    );
    
    SET p_cust_order_id = LAST_INSERT_ID();
    
    -- Process each basket item
    OPEN basket_cursor;
    
    read_loop: LOOP
        FETCH basket_cursor INTO v_basket_item_id, v_listing_id, v_seller_id, v_quantity, v_unit_price, v_vat_rate;
        IF done THEN
            LEAVE read_loop;
        END IF;    
        -- Check actual stock availability (stock_on_hand - reserved)
        SELECT (stock_on_hand - reserved) INTO v_reserved_qty
        FROM Listing
        WHERE listing_id = v_listing_id
        FOR UPDATE;
        
        -- Fail safely if insufficient stock
        IF v_reserved_qty IS NULL OR v_reserved_qty < v_quantity THEN
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'Insufficient stock during checkout. Please refresh your cart.';
        END IF;
        
        -- Check if seller_order exists for this seller in this order
        -- Use a subquery to avoid NOT FOUND issues
        SET v_seller_order_id = (
            SELECT seller_order_id
            FROM Seller_Order
            WHERE seller_id = v_seller_id AND cust_order_id = p_cust_order_id
            LIMIT 1
        );
        
        IF v_seller_order_id IS NULL THEN
            -- Create new Seller_Order
            INSERT INTO Seller_Order (
                seller_id, 
                cust_order_id, 
                status, 
                item_subtotal, 
                created_at
            ) VALUES (
                v_seller_id, 
                p_cust_order_id, 
                'Created', 
                0, 
                NOW()
            );
            SET v_seller_order_id = LAST_INSERT_ID();
        END IF;
        
        -- Create Order_Item
        INSERT INTO Order_Item (
            listing_id, 
            seller_order_id, 
            list_price_at_sale, 
            unit_price_at_sale, 
            quantity, 
            tax_rate
        ) VALUES (
            v_listing_id, 
            v_seller_order_id, 
            v_unit_price, 
            v_unit_price, 
            v_quantity, 
            v_vat_rate
        );
        
        SET v_new_order_item_id = LAST_INSERT_ID();
        
        -- Update Seller_Order subtotal
        UPDATE Seller_Order
        SET item_subtotal = item_subtotal + (v_unit_price * v_quantity)
        WHERE seller_order_id = v_seller_order_id;
        
        -- Reserve stock for the order
        UPDATE Listing
        SET reserved = reserved + v_quantity
        WHERE listing_id = v_listing_id;
        
        -- Create order-level reservation record
        INSERT INTO Stock_Reservation (
            listing_id,
            order_item_id,
            quantity,
            created_at,
            status
        ) VALUES (
            v_listing_id,
            v_new_order_item_id,
            v_quantity,
            NOW(),
            'Confirmed'
        );
        
    END LOOP;
    
    CLOSE basket_cursor;
    
    -- Archive the basket
    UPDATE Basket
    SET is_active = 0, archived_at = NOW()
    WHERE basket_id = p_basket_id;
    
    COMMIT;
    
END$$

-- PROCEDURE: Cancel Seller Order
CREATE PROCEDURE sp_cancel_seller_order(
    IN p_seller_order_id INT,
    IN p_cancel_reason VARCHAR(255)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    START TRANSACTION;

    -- 1. Update Seller Order Status (triggers status history)
    UPDATE Seller_Order 
    SET status = 'Cancelled' 
    WHERE seller_order_id = p_seller_order_id
      AND status NOT IN ('Shipped', 'Delivered', 'Cancelled');

    -- 2. Release Stock & Update Reservations (only for non-shipped seller orders)
    -- Join Seller_Order to ensure we only release if cancellation was applied
    UPDATE Listing l
    JOIN Order_Item oi ON l.listing_id = oi.listing_id
    JOIN Seller_Order so ON so.seller_order_id = oi.seller_order_id
    JOIN Stock_Reservation sr ON sr.order_item_id = oi.order_item_id
    SET 
        l.reserved = GREATEST(l.reserved - sr.quantity, 0),
        sr.status = 'Cancelled'
    WHERE so.seller_order_id = p_seller_order_id
      AND so.status = 'Cancelled'
      AND sr.status IN ('Confirmed', 'Active');

    COMMIT;
    
    SELECT 'SUCCESS' AS result, 'Seller order cancelled successfully' AS message;
END$$


-- PROCEDURE: Cancel Customer Order
CREATE PROCEDURE sp_cancel_customer_order(
    IN p_cust_order_id INT,
    IN p_cancel_reason VARCHAR(255)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    START TRANSACTION;

    -- 1. Update Customer Order Status (triggers status history)
    UPDATE Customer_Order 
    SET status = 'Cancelled' 
    WHERE cust_order_id = p_cust_order_id
      AND status NOT IN ('Shipped', 'Delivered', 'Cancelled');

    -- 2. Update all Seller Orders (triggers status history for each)
    UPDATE Seller_Order 
    SET status = 'Cancelled' 
    WHERE cust_order_id = p_cust_order_id
      AND status NOT IN ('Shipped', 'Delivered', 'Cancelled');

    -- 3. Release Stock & Update Reservations only for cancelled seller orders
    -- This ensures we don't release stock for already-shipped lines
    UPDATE Listing l
    JOIN Order_Item oi ON l.listing_id = oi.listing_id
    JOIN Seller_Order so ON so.seller_order_id = oi.seller_order_id
    JOIN Stock_Reservation sr ON sr.order_item_id = oi.order_item_id
    SET 
        l.reserved = GREATEST(l.reserved - sr.quantity, 0),
        sr.status = 'Cancelled'
    WHERE so.cust_order_id = p_cust_order_id
      AND so.status = 'Cancelled'
      AND sr.status IN ('Confirmed', 'Active');

    COMMIT;
    
    SELECT 'SUCCESS' AS result, 'Customer order cancelled successfully' AS message;
END$$

-- TRIGGER: Validate payment is captured before shipment
CREATE TRIGGER trg_shipment_payment_check
BEFORE UPDATE ON Shipment
FOR EACH ROW
BEGIN
    DECLARE v_all_seller_orders_total DECIMAL(19,4);
    DECLARE v_captured_amount DECIMAL(19,4);
    DECLARE v_cust_order_id INT;
    
    -- Only check when transitioning TO 'Shipped' status
    IF NEW.status = 'Shipped' AND OLD.status <> 'Shipped' THEN
        
        -- Get the customer order ID
        SELECT so.cust_order_id INTO v_cust_order_id
        FROM Seller_Order so
        WHERE so.seller_order_id = NEW.seller_order_id;
        
        -- Calculate total of ALL active (non-cancelled) seller orders for this customer order
        SELECT COALESCE(SUM(item_subtotal + COALESCE(shipping_total, 0)), 0)
        INTO v_all_seller_orders_total
        FROM Seller_Order
        WHERE cust_order_id = v_cust_order_id
          AND status NOT IN ('Cancelled', 'Refunded');
        
        -- Calculate total captured payments for this customer order
        SELECT COALESCE(SUM(amount), 0) INTO v_captured_amount
        FROM Payment
        WHERE cust_order_id = v_cust_order_id
          AND status IN ('Captured', 'Completed');
        
        -- Check if sufficient payment exists for ALL active seller orders
        IF v_captured_amount < v_all_seller_orders_total THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Insufficient payment. Total captured payments must cover all active seller orders.';
        END IF;
    END IF;
END$$


-- TRIGGER: Validate review is for delivered items only
-- Customer can only review a product variant they have received
CREATE TRIGGER trg_review_delivery_check
BEFORE INSERT ON Review
FOR EACH ROW
BEGIN
    DECLARE v_delivered_count INT;
    
    -- Check if this customer has received this product variant
    -- (join through Seller_Order since Order_Item has no cust_order_id)
    SELECT COUNT(*) INTO v_delivered_count
    FROM Shipment_Item si
    JOIN Shipment s ON s.shipment_id = si.shipment_id
    JOIN Order_Item oi ON oi.order_item_id = si.order_item_id
    JOIN Listing l ON l.listing_id = oi.listing_id
    JOIN Seller_Order so ON oi.seller_order_id = so.seller_order_id
    JOIN Customer_Order co ON so.cust_order_id = co.cust_order_id
    WHERE co.customer_id = NEW.customer_id
      AND l.product_variant_id = NEW.product_variant_id
      AND s.status = 'Delivered';
    
    IF v_delivered_count = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Cannot review: Product must be delivered before submitting a review.';
    END IF;
END$$


-- TRIGGER: Prevent Seller Order completion if shipments pending
-- Seller Order cannot be 'Completed' unless all shipments delivered
CREATE TRIGGER trg_sellerorder_completion_check
BEFORE UPDATE ON Seller_Order
FOR EACH ROW
BEGIN
    DECLARE v_total_ordered INT;
    DECLARE v_total_delivered INT;
    
    -- Only check when transitioning TO 'Completed' status
    IF NEW.status = 'Completed' AND OLD.status <> 'Completed' THEN
        
        -- Get total quantity ordered
        SELECT COALESCE(SUM(quantity), 0) INTO v_total_ordered
        FROM Order_Item
        WHERE seller_order_id = NEW.seller_order_id;
        
        -- Get total quantity delivered (from shipments with 'Delivered' status)
        SELECT COALESCE(SUM(si.shipped_quantity), 0) INTO v_total_delivered
        FROM Shipment_Item si
        JOIN Shipment s ON s.shipment_id = si.shipment_id
        JOIN Order_Item oi ON oi.order_item_id = si.order_item_id
        WHERE oi.seller_order_id = NEW.seller_order_id
          AND s.status = 'Delivered';
        
        -- Prevent completion if not all items delivered
        IF v_total_delivered < v_total_ordered THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Cannot complete Seller Order: Not all items have been delivered.';
        END IF;
    END IF;
END$$


-- TRIGGER: Auto-update Customer Order status based on Seller Orders
-- Roll-up logic: derives customer order status from seller orders
CREATE TRIGGER trg_sellerorder_rollup_status
AFTER UPDATE ON Seller_Order
FOR EACH ROW
BEGIN
    DECLARE v_total_seller_orders INT;
    DECLARE v_cancelled_count INT;
    DECLARE v_completed_count INT;
    DECLARE v_shipped_count INT;
    DECLARE v_processing_count INT;
    DECLARE v_new_status VARCHAR(50);
    DECLARE v_current_status VARCHAR(50);
    
    -- Get current customer order status
    SELECT status INTO v_current_status
    FROM Customer_Order
    WHERE cust_order_id = NEW.cust_order_id;
    
    -- Don't update if customer order is already Cancelled
    IF v_current_status = 'Cancelled' THEN
        -- Do nothing, exit trigger
        SET v_new_status = NULL;
    ELSE
        -- Count seller orders by status
        SELECT 
            COUNT(*),
            SUM(CASE WHEN status = 'Cancelled' THEN 1 ELSE 0 END),
            SUM(CASE WHEN status = 'Completed' THEN 1 ELSE 0 END),
            SUM(CASE WHEN status IN ('Shipped', 'Delivered') THEN 1 ELSE 0 END),
            SUM(CASE WHEN status IN ('Created', 'Processing', 'Pending') THEN 1 ELSE 0 END)
        INTO v_total_seller_orders, v_cancelled_count, v_completed_count, v_shipped_count, v_processing_count
        FROM Seller_Order
        WHERE cust_order_id = NEW.cust_order_id;
        
        -- Determine new customer order status
        IF v_cancelled_count = v_total_seller_orders THEN
            SET v_new_status = 'Cancelled';
        ELSEIF v_completed_count = v_total_seller_orders THEN
            SET v_new_status = 'Completed';
        ELSEIF v_shipped_count > 0 OR v_completed_count > 0 THEN
            SET v_new_status = 'Partially Shipped';
        ELSEIF v_processing_count > 0 THEN
            SET v_new_status = 'Processing';
        ELSE
            SET v_new_status = 'Created';
        END IF;
        
        -- Update customer order status if it changed
        IF v_new_status IS NOT NULL AND v_new_status <> v_current_status THEN
            UPDATE Customer_Order
            SET status = v_new_status
            WHERE cust_order_id = NEW.cust_order_id;
        END IF;
    END IF;
END$$

-- PROCEDURE: Seller Restock
-- Records stock replenishment with proper Stock_Movement entry
CREATE PROCEDURE sp_seller_restock(
    IN p_listing_id INT,
    IN p_quantity INT,
    IN p_reason VARCHAR(255)
)
BEGIN
    DECLARE v_exists INT;
    
    -- Check listing exists
    SELECT COUNT(*) INTO v_exists
    FROM Listing
    WHERE listing_id = p_listing_id;
    
    IF v_exists = 0 THEN
        SELECT 'FAILED' AS result, 'Listing not found' AS message;
    ELSEIF p_quantity <= 0 THEN
        SELECT 'FAILED' AS result, 'Quantity must be greater than 0' AS message;
    ELSE
        -- Update stock
        UPDATE Listing
        SET stock_on_hand = stock_on_hand + p_quantity
        WHERE listing_id = p_listing_id;
        
        -- Record stock movement
        INSERT INTO Stock_Movement (
            listing_id,
            order_item_id,
            return_item_id,
            movement_type,
            quantity,
            created_at
        ) VALUES (
            p_listing_id,
            NULL,
            NULL,
            'RESTOCK',
            p_quantity,
            NOW()
        );
        
        SELECT 'SUCCESS' AS result, 
               CONCAT('Added ', p_quantity, ' units to stock. Reason: ', COALESCE(p_reason, 'N/A')) AS message;
    END IF;
END$$

-- TRIGGER: Log Stock_Movement when reservation is created/confirmed
-- Records RESERVATION movement type for order confirmations
CREATE TRIGGER trg_reservation_stock_movement
AFTER INSERT ON Stock_Reservation
FOR EACH ROW
BEGIN
    -- Log reservation movement when it's for an order (not basket - those are temporary)
    IF NEW.order_item_id IS NOT NULL AND NEW.status = 'Confirmed' THEN
        INSERT INTO Stock_Movement (
            listing_id,
            order_item_id,
            return_item_id,
            movement_type,
            quantity,
            created_at
        ) VALUES (
            NEW.listing_id,
            NEW.order_item_id,
            NULL,
            'RESERVATION',
            NEW.quantity,
            NOW()
        );
    END IF;
END$$

-- TRIGGER: Validate Payment Allocation covers Seller Order before shipment
CREATE TRIGGER trg_shipment_allocation_check
BEFORE UPDATE ON Shipment
FOR EACH ROW
BEGIN
    DECLARE v_seller_order_total DECIMAL(19,4);
    DECLARE v_allocated_amount DECIMAL(19,4);
    
    -- Only check when transitioning TO 'Shipped' status
    IF NEW.status = 'Shipped' AND OLD.status <> 'Shipped' THEN
        
        -- Get the seller order total
        SELECT item_subtotal + COALESCE(shipping_total, 0)
        INTO v_seller_order_total
        FROM Seller_Order
        WHERE seller_order_id = NEW.seller_order_id;
        
        -- Calculate total allocated payments for THIS seller order
        SELECT COALESCE(SUM(pa.amount), 0) INTO v_allocated_amount
        FROM Payment_Allocation pa
        JOIN Payment p ON p.payment_id = pa.payment_id
        WHERE pa.seller_order_id = NEW.seller_order_id
          AND p.status IN ('Captured', 'Completed');
        
        -- Check if sufficient allocation exists for this specific seller order
        IF v_allocated_amount < v_seller_order_total THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Insufficient payment allocation for this Seller Order. Allocate payment before shipping.';
        END IF;
    END IF;
END$$

-- TRIGGER: Enforce Return lifecycle state machine
CREATE TRIGGER trg_return_lifecycle
BEFORE UPDATE ON Order_Return
FOR EACH ROW
BEGIN
    DECLARE v_valid_transition TINYINT DEFAULT 0;
    
    -- Allow bypass for testing (SET @DISABLE_RETURN_TRIGGER = TRUE before UPDATE)
    IF @DISABLE_RETURN_TRIGGER = TRUE THEN
        SET @DISABLE_RETURN_TRIGGER = FALSE; -- Auto-reset
    ELSE
        -- Only validate if status is changing
        IF OLD.status <> NEW.status THEN
            -- Define valid transitions
            IF OLD.status = 'Requested' AND NEW.status IN ('Approved', 'Cancelled') THEN
                SET v_valid_transition = 1;
            ELSEIF OLD.status = 'Approved' AND NEW.status IN ('Received', 'Cancelled') THEN
                SET v_valid_transition = 1;
            ELSEIF OLD.status = 'Received' AND NEW.status IN ('Completed', 'Cancelled') THEN
                SET v_valid_transition = 1;
            ELSEIF NEW.status = 'Cancelled' AND OLD.status <> 'Completed' THEN
                -- Can cancel from any state except Completed
                SET v_valid_transition = 1;
            END IF;
            
            IF v_valid_transition = 0 THEN
                SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Invalid return status transition. Valid: Requested→Approved→Received→Completed (or Cancelled)';
            END IF;
        END IF;
    END IF;
END$$


-- TRIGGER: Enforce one active basket per customer
-- A customer may have only one active basket at a time
CREATE TRIGGER trg_basket_one_active
BEFORE INSERT ON Basket
FOR EACH ROW
BEGIN
    DECLARE v_active_count INT;
    
    IF NEW.is_active = 1 THEN
        SELECT COUNT(*) INTO v_active_count
        FROM Basket
        WHERE customer_id = NEW.customer_id
          AND is_active = 1;
        
        IF v_active_count > 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Customer already has an active basket. Archive or deactivate existing basket first.';
        END IF;
    END IF;
END$$


-- TRIGGER: Only active listings can be ordered
-- Prevents adding deactivated listings to orders
CREATE TRIGGER trg_orderitem_active_listing
BEFORE INSERT ON Order_Item
FOR EACH ROW
BEGIN
    DECLARE v_is_active TINYINT;
    
    SELECT is_active INTO v_is_active
    FROM Listing
    WHERE listing_id = NEW.listing_id;
    
    IF v_is_active IS NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Listing not found.';
    ELSEIF v_is_active = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Cannot order from inactive listing. The product may no longer be available.';
    END IF;
END$$


-- ============================================================
-- FUNCTIONS (User-Defined Functions)
-- ============================================================

-- FUNCTION 1: Calculate total for a Customer Order
-- Returns the sum of all order items including tax
CREATE FUNCTION fn_calculate_order_total(p_cust_order_id INT)
RETURNS DECIMAL(19,4)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE v_total DECIMAL(19,4);
    
    SELECT COALESCE(SUM(
        oi.unit_price_at_sale * oi.quantity * (1 + oi.tax_rate / 100)
    ), 0)
    INTO v_total
    FROM Order_Item oi
    JOIN Seller_Order so ON oi.seller_order_id = so.seller_order_id
    WHERE so.cust_order_id = p_cust_order_id;
    
    RETURN v_total;
END$$


-- FUNCTION 2: Get available stock for a Listing
-- Returns: stock_on_hand - reserved (available for new orders)
CREATE FUNCTION fn_get_available_stock(p_listing_id INT)
RETURNS INT
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE v_available INT;
    
    SELECT GREATEST(stock_on_hand - reserved, 0)
    INTO v_available
    FROM Listing
    WHERE listing_id = p_listing_id;
    
    RETURN COALESCE(v_available, 0);
END$$


-- FUNCTION 3: Calculate seller earnings after commission
-- Returns: order total minus marketplace commission
CREATE FUNCTION fn_calculate_seller_earnings(p_seller_order_id INT)
RETURNS DECIMAL(19,4)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE v_earnings DECIMAL(19,4);
    
    SELECT COALESCE(SUM(
        oi.unit_price_at_sale * oi.quantity * (1 - oi.commission_rate / 100)
    ), 0)
    INTO v_earnings
    FROM Order_Item oi
    WHERE oi.seller_order_id = p_seller_order_id;
    
    RETURN v_earnings;
END$$

DELIMITER ;
